package pokemon;

import Exceptions.BadPokemonException;
import Exceptions.BadSaveDataException;
import java.util.Random;

import item.Item;
import item.Pokedex;
import item.concreteItems.genericItems.DestinyKnot;
import item.concreteItems.genericItems.Everstone;
import java.io.Serializable;
import java.util.UUID;
import move.Move;
import move.enums.MoveEffect;
import character.Player;
import character.Trainer;

/**
 * @author ellen
 *
 */
public class Pokemon implements Serializable {

    private static final long serialVersionUID = 1L;
    
    //TODO pokedex indexes! - should be autogenerated to ensure correct numbering
    // enums will handle this!
    private static Random generator = new Random();

    final static int FEMALE = 0;
    final static int MALE = 1;
    final static int NO_GENDER = 2;

    final static int MIN_LEVEL = 1;
    final static int MAX_LEVEL = 100;

    private static final transient int MAX_EV = 510;
    private static final transient int MAX_EV_PER_STAT = 252;

    private static final transient int MAX_IV = 31;

    private static final transient int BASE_FRIENDLINESS = 70;

    //TODO made these enums, so fix implementation!
    public static final transient int ATTACK = 0;
    public static final transient int DEFENSE = 1;
    public static final transient int SP_ATTACK = 2;
    public static final transient int SP_DEFENSE = 3;
    public static final transient int SPEED = 4;
    public static final transient int ACCURACY = 5;
    public static final transient int EVASIVENESS = 6;

    public static final transient int HP = 7;

    public static final transient int NUM_STATS = 7;

    private static final transient int SHINY_CHANCE = 10000;

    private static final transient double[] CONDITION_EFFECT_VALUES = {1.5, 1.5, 1.5, 2, 2};
    private final String[] statNames = {"ATK", "DEF", "SP ATK", "SP DEF", "SPD"};

    /*
     * Species general things
     */
    private Species species;

    /* Individual pkmn things */
    private int level, exp, expToNextLevel;
    private int currentHP, maxHP, baseHP;
    private int gender;
    private int friendliness;
    private Nature nature;
    private Ability ability;
    private String nickname;
    private Item item;
    private Trainer trainer;
    private UUID originalTrainerId;
    private Move[] moves = new Move[4];
    private boolean shiny;
    private LevelGrowthRate levelGrowthRate;
    /* Hold base (generated) values for all stats */
    private int[] myBaseStats;
    /* Holds multiplies for all stats */
    private double[] statMultipliers;
    /* Holds things like modifiers due to items */
    private int[] currentStatModifiers;
    /* Corresponds to stat arrays, holds EVs for each stat */
    private int[] evs;
    private int[] ivs;
    /* Modifiers to how fast friendliness increases (multiplier) */
    private double friendlinessMultiplier = 1;

    private boolean isConfused;
    private Condition currentCondition; // conditions overwrite each other, so we need to know which is on top

    private double[] natureValue;
    private UUID pkmnID;

    private boolean otherEvolveCondition = true;

    /**
     * Basic constructor for a Pokemon
     *
     * @param pokedexNo the pokedexNo of the species
     * @param level the level to set
     */
    public Pokemon(int pokedexNo, int level) {
        pkmnID = UUID.randomUUID();

//        this.speciesName = speciesName;
        species = Pokedex.getPokemonSpeciesInfo(pokedexNo);
        this.level = level;
        gender = generateGender();
//        ability = randomizeAbility();

        shiny = randomizeShiny();
        levelGrowthRate = randomizeLevelGrowthRate();
        updateExpToNextLevel();

        myBaseStats = new int[NUM_STATS];
        statMultipliers = new double[NUM_STATS];
        currentStatModifiers = new int[NUM_STATS];
        evs = new int[NUM_STATS + 1]; // one bigger bc has HP as well
        ivs = new int[NUM_STATS + 1];
        natureValue = new double[NUM_STATS];

        myBaseStats[ATTACK] = species.getSpeciesBaseStats()[ATTACK] + generateStatModifier(ATTACK);
        myBaseStats[DEFENSE] = species.getSpeciesBaseStats()[DEFENSE] + generateStatModifier(DEFENSE);
        myBaseStats[SP_ATTACK] = species.getSpeciesBaseStats()[SP_ATTACK] + generateStatModifier(SP_ATTACK);
        myBaseStats[SP_DEFENSE] = species.getSpeciesBaseStats()[SP_DEFENSE] + generateStatModifier(SP_DEFENSE);
        myBaseStats[SPEED] = species.getSpeciesBaseStats()[SPEED] + generateStatModifier(SPEED);
        myBaseStats[ACCURACY] = species.getSpeciesBaseStats()[ACCURACY] + generateStatModifier(ACCURACY);
        myBaseStats[EVASIVENESS] = species.getSpeciesBaseStats()[EVASIVENESS] + generateStatModifier(EVASIVENESS);

        baseHP = species.getSpeciesBaseStats()[HP] + generateStatModifier(HP);

        generateIVs();

        calculuateMaxHP(level);
        currentHP = maxHP;
        friendliness = BASE_FRIENDLINESS;

        for (int i = 0; i < NUM_STATS; i++) {
            statMultipliers[i] = 1;
            natureValue[i] = 1;
        }

        randomizeNature(); //goes last bc modifies some stats!
    }

    /**
     *
     * @param pokedexNo
     * @param nickname
     * @param gender
     * @param level
     * @param shiny
     * @param nature
     * @param moves
     * @param trainer
     */
    public Pokemon(int pokedexNo, String nickname,
            int gender, int level, boolean shiny,
            Nature nature, Move[] moves, Trainer trainer) {
        this(pokedexNo, level);
        this.gender = gender;
        this.shiny = shiny;
        this.nature = nature;
        this.nickname = nickname;
        this.moves = moves;
        this.trainer = trainer;
        if (trainer instanceof Player) {
            originalTrainerId = ((Player) trainer).getPlayerId();
        }
    }

//    /**
//     * Constructor for making a Pokemon from loaded game data
//     *
//     * @param speciesName
//     * @param nickname
//     * @param trainer
//     * @param level
//     * @param shiny
//     * @param friendliness
//     * @param friendlinessMod
//     * @param currentHP
//     * @param currentEXP
//     * @param ivs
//     * @param evs
//     * @param baseStats
//     * @param baseHP
//     * @param condition
//     * @param lvlGrowthRate
//     * @param nature
//     * @param confused
//     * @param itemId
//     * @param move1Name
//     * @param move2Name
//     * @param move3Name
//     * @param move4Name
//     * @param move1PP
//     * @param move2PP
//     * @param move3PP
//     * @param move4PP
//     */
//    public Pokemon(String speciesName, String nickname, Trainer trainer,
//            int level, boolean shiny, int friendliness, double friendlinessMod,
//            int currentHP, int currentEXP, int[] ivs, int[] evs, int[] baseStats,
//            int baseHP, String condition, String lvlGrowthRate,
//            String nature, boolean confused, String itemId,
//            String move1Name, String move2Name,
//            String move3Name, String move4Name,
//            int move1PP, int move2PP, int move3PP, int move4PP) {
//        this(PkmnSpecies.valueOf(speciesName), level);
//        this.nickname = nickname;
//        this.level = level;
//        this.shiny = shiny;
//        exp = currentEXP;
//        this.ivs = ivs;
//        this.evs = evs;
//        this.myBaseStats = baseStats;
//        this.baseHP = baseHP;
//        currentCondition = Condition.valueOf(condition);
//        this.levelGrowthRate = LevelGrowthRate.valueOf(lvlGrowthRate);
//        this.nature = Nature.valueOf(nature);
//        this.isConfused = confused;
//        try {
//            this.item = Item.readItem(itemId);
//        } catch (NamingException ex) {
//            Logger.getLogger(Pokemon.class.getName()).log(Level.SEVERE, null, ex);
//        }
//        this.trainer = trainer;
//
//        moves[0] = getMoveFromString(move1Name);
//        moves[0].setRemainingPP(move1PP);
//        moves[1] = getMoveFromString(move2Name);
//        moves[1].setRemainingPP(move2PP);
//        moves[2] = getMoveFromString(move3Name);
//        moves[2].setRemainingPP(move3PP);
//        moves[3] = getMoveFromString(move4Name);
//        moves[3].setRemainingPP(move4PP);
//    }

    /**
     * To be used for breeding Pokemon
     *
     * @param trainer
     * @param pokedexNo
     * @param ivs inherited IVs from parents (-1 if not an inherited value)
     */
    public Pokemon(Player trainer, int pokedexNo, int[] ivs) {
        this(pokedexNo, MIN_LEVEL);
        this.trainer = trainer;
        originalTrainerId = trainer.getPlayerId();
        this.ivs = ivs;
        for (int i = 0; i < NUM_STATS + 1; i++) {
            if (this.ivs[i] == -1) {
                ivs[i] = generator.nextInt(MAX_IV + 1);
            }
        }
    }

    /**
     * For breeding Pokemon with an inherited nature
     *
     * @param trainer
     * @param pokedexNo
     * @param ivs
     * @param nature
     */
    public Pokemon(Player trainer, int pokedexNo, int[] ivs, Nature nature) {
        this(trainer, pokedexNo, ivs);
        this.nature = nature;
    }

    /*----------------------------------- STAT GENERATION ---------------------------------------*/
    /**
     * Generates a random number within the bounds of the modifier to be added
     * or subtracted from the base stat
     *
     * @param modifierValue the maximum variance of the stat
     * @return a positive integer within the bounds of the modifier
     */
    protected int statModifier(int modifierValue) {
        return generator.nextInt(modifierValue + 1);
    }

    /**
     * Takes the value of the modifier returned by statModifier and randomly
     * makes it positive or negative
     *
     * @param statNumber the stat to apply the modifier to (eg Attack)
     * @return a positive or negative value to be added to the stat
     */
    private int generateStatModifier(int statNumber) {
        return (int) (Math.pow(-1, generator.nextInt(2))
                * statModifier(species.getModifier()[statNumber]));
    }

    /**
     * Determines whether the Pokemon will be shiny. There is a 1 / 10,000
     * chance that it will be shiny.
     *
     * @return true if the Pokemon is shiny
     */
    private boolean randomizeShiny() {
        int i = generator.nextInt(SHINY_CHANCE);
        return i == 0;
    }

    /**
     * Determine the Level Growth Rate of the Pokemon, which determines how much
     * EXP is required to level up
     *
     * @return the LevelGrowthRate to be assigned to the Pokemon
     */
    private LevelGrowthRate randomizeLevelGrowthRate() {
        switch (generator.nextInt(4)) {
            case 0:
                return LevelGrowthRate.FAST;
            case 1:
                return LevelGrowthRate.MEDIUM_FAST;
            case 2:
                return LevelGrowthRate.MEDIUM_SLOW;
            case 3:
                return LevelGrowthRate.SLOW;
        }
        throw new BadPokemonException("Bad LevelGrowthRate");
    }

    /**
     * Generate random values between 0 and 31 for each IV
     */
    private void generateIVs() {
        for (int i = 0; i < ivs.length; i++) {
            ivs[i] = generator.nextInt(MAX_IV + 1);
        }
    }

    /**
     * Determine the Pokemon's nature. Nature also causes some stat changes, and
     * these are handled in here as well.
     */
    private void randomizeNature() {
        switch (generator.nextInt(25)) {
            case 0:
                nature = Nature.HARDY;
                // no stat changes
                break;
            case 1:
                nature = Nature.LONELY;
                natureStats(ATTACK, DEFENSE);
                break;
            case 2:
                nature = Nature.BRAVE;
                natureStats(ATTACK, SPEED);
                break;
            case 3:
                nature = Nature.ADAMANT;
                natureStats(ATTACK, SP_ATTACK);
                break;
            case 4:
                nature = Nature.NAUGHTY;
                natureStats(ATTACK, SP_DEFENSE);
                break;
            case 5:
                nature = Nature.BOLD;
                natureStats(DEFENSE, ATTACK);
                break;
            case 6:
                nature = Nature.DOCILE;
                break;
            case 7:
                nature = Nature.RELAXED;
                natureStats(DEFENSE, SPEED);
                break;
            case 8:
                nature = Nature.IMPISH;
                natureStats(DEFENSE, SP_ATTACK);
                break;
            case 9:
                nature = Nature.LAX;
                natureStats(DEFENSE, SP_DEFENSE);
                break;
            case 10:
                nature = Nature.TIMID;
                natureStats(SPEED, ATTACK);
                break;
            case 11:
                nature = Nature.HASTY;
                natureStats(SPEED, DEFENSE);
                break;
            case 12:
                nature = Nature.SERIOUS;
                break;
            case 13:
                nature = Nature.JOLLY;
                natureStats(SPEED, SP_ATTACK);
                break;
            case 14:
                nature = Nature.NAIVE;
                natureStats(SPEED, SP_DEFENSE);
                break;
            case 15:
                nature = Nature.MODEST;
                natureStats(SP_ATTACK, ATTACK);
                break;
            case 16:
                nature = Nature.MILD;
                natureStats(SP_ATTACK, DEFENSE);
                break;
            case 17:
                nature = Nature.QUIET;
                natureStats(SP_ATTACK, SPEED);
                break;
            case 18:
                nature = Nature.BASHFUL;
                break;
            case 19:
                nature = Nature.RASH;
                natureStats(SP_ATTACK, SP_DEFENSE);
                break;
            case 20:
                nature = Nature.CALM;
                natureStats(SP_DEFENSE, ATTACK);
                break;
            case 21:
                nature = Nature.GENTLE;
                natureStats(SP_DEFENSE, DEFENSE);
                break;
            case 22:
                nature = Nature.SASSY;
                natureStats(SP_DEFENSE, SPEED);
                break;
            case 23:
                nature = Nature.CAREFUL;
                natureStats(SP_DEFENSE, SP_ATTACK);
                break;
            case 24:
                nature = Nature.QUIRKY;
                break;
        }
    }

    /**
     * Alter the stats as determined by the Pokemon's nature
     *
     * @param raisedStat the stat to increase by 10%
     * @param loweredStat the stat to decrease by 10%
     */
    private void natureStats(int raisedStat, int loweredStat) {
        natureValue[raisedStat] = 1.1;
        natureValue[loweredStat] = 0.9;
    }

    /**
     * TODO Determine the Pokemon's ability, based on the probabilities provided
     * by the species' ability likelihood array.
     *
     * @return the ability to assign to the Pokemon
     */
    private Ability randomizeAbility() {
        int i = generator.nextInt(100) + 1;
        int[] percents = species.getPercentLikelihoodAbilities();
        for (int idx = 0; idx < percents.length; idx++) {
            if (i < percents[idx]) {
                return species.getAbilities()[idx];
            }
        }
        return null;
    }

    /**
     * Determine the gender of the Pokemon. If the randomly generated integer is
     * less than or equal to the percentage of that species that is male, then
     * the Pokemon is male. If the species is genderless, percentMale is -1.
     *
     * @return the gender of the Pokemon
     */
    private int generateGender() {
        if (species.getPercentMale() == -1) {
            return NO_GENDER;
        }
        if (generator.nextInt(101) <= species.getPercentMale()) {
            return MALE;
        }
        return FEMALE;
    }

    /**
     * Calculates the maximum HP for the Pokemon based on level, IVs and EVs for
     * HP, and base HP
     *
     * @param level the current level of the Pokemon
     */
    private void calculuateMaxHP(int level) {
        maxHP = (((ivs[HP] + (2 * baseHP) + (evs[HP] / 4)) * level) / 100) + 10 + level;
    }

    /*-------------------------------------- GETTERS -------------------------------------------*/
    public UUID getPkmnID() {
        return pkmnID;
    }

    /**
     * Get the Pokemon's current level
     *
     * @return the level
     */
    public int getLevel() {
        return level;
    }

    /**
     * Get the amount of EXP the Pokemon currently has
     *
     * @return the EXP
     */
    public int getExp() {
        return exp;
    }

    /**
     * Get the Pokemon's current remaining HP
     *
     * @return the currentHP
     */
    public int getCurrentHP() {
        return currentHP;
    }

    /**
     * @return the maxHP
     */
    public int getMaxHP() {
        return maxHP;
    }

    /**
     * @return the gender
     */
    public int getGender() {
        return gender;
    }

    /**
     * @return the friendliness
     */
    public int getFriendliness() {
        return friendliness;
    }

    /**
     * @return the personality
     */
    public Nature getPersonality() {
        return nature;
    }

    /**
     * @return the description
     */
    public String getDescription() {
        return species.getDescription();
    }

    /**
     * @return the name
     */
    public String getName() {
        return species.getName();
    }

    /**
     * @return the nickname
     */
    public String getNickname() {
        return nickname;
    }

    /**
     * @return the type
     */
    public PkmnType[] getTypes() {
        return species.getTypes();
    }

    /**
     * @return the item
     */
    public Item getItem() {
        return item;
    }

    /**
     * @return the trainer
     */
    public Trainer getTrainer() {
        return trainer;
    }

    /**
     * @return the moves
     */
    public Move[] getMoves() {
        return moves;
    }

//    /**
//     * @return the bottomEvolution
//     */
//    public PkmnSpecies getBottomEvolution() {
//        return species.getBottomEvolution();
//    }

//    /**
//     * @return the nextEvolution
//     */
//    public PkmnSpecies getNextEvolution() {
//        return species.getNextEvolution();
//    }

    public EggGroup[] getEggGroup() {
        return species.getEggGroup();
    }

    /**
     * @return the shiny
     */
    public boolean isShiny() {
        return shiny;
    }

    public int getPokedexNo() {
        return species.getPokedexNo();
    }

    /**
     * @return the baseAttack
     */
    public int getBaseAttack() {
        return myBaseStats[ATTACK];
    }

    /**
     * @return the baseDefense
     */
    public int getBaseDefense() {
        return myBaseStats[DEFENSE];
    }

    /**
     * @return the baseSPAttack
     */
    public int getBaseSpAttack() {
        return myBaseStats[SP_ATTACK];
    }

    /**
     * @return the baseSPDefense
     */
    public int getBaseSpDefense() {
        return myBaseStats[SP_DEFENSE];
    }

    /**
     * @return the baseSpeed
     */
    private int getBaseSpeed() {
        return myBaseStats[SPEED];
    }

    /**
     * @return the baseAccuracy
     */
    private int getBaseAccuracy() {
        return myBaseStats[ACCURACY];
    }

    /**
     * @return the baseEvasiveness
     */
    public int getBaseEvasiveness() {
        return myBaseStats[EVASIVENESS];
    }

    /**
     * @return the attack
     */
    public int getAttack() {
        return getBaseAttack() + currentStatModifiers[ATTACK];
    }

    /**
     * @return the defense
     */
    public int getDefense() {
        return getBaseDefense() + currentStatModifiers[DEFENSE];
    }

    /**
     * @return the spAttack
     */
    public int getSpAttack() {
        return getBaseSpAttack() + currentStatModifiers[SP_ATTACK];
    }

    /**
     * @return the spDefense
     */
    public int getSpDefense() {
        return getBaseSpDefense() + currentStatModifiers[SP_DEFENSE];
    }

    /**
     * @return the speed
     */
    public int getSpeed() {
        return getBaseSpeed() + currentStatModifiers[SPEED];
    }

    /**
     * @return the accuracy
     */
    public int getAccuracy() {
        return getBaseAccuracy() + currentStatModifiers[ACCURACY];
    }

    /**
     * @return the evasiveness
     */
    public int getEvasiveness() {
        return getBaseEvasiveness() + currentStatModifiers[EVASIVENESS];
    }

    private int[] getIvs() {
        return ivs;
    }

    private int[] getEvs() {
        return evs;
    }

    public Move[] getMoveSet() {
        return species.getMoveSet();
    }

    public int[] getSpeciesBaseStats() {
        return species.getSpeciesBaseStats();
    }

    public int[] getModifier() {
        return species.getModifier();
    }

    public int getCatchChance() {
        return species.getCatchChance();
    }

    public int getPercentMale() {
        return species.getPercentMale();
    }

    public Ability getAbility() {
        return ability;
    }

    /**
     * Checks evolveCondition and any other requirements to evolve
     *
     * @return true if the Pokemon meets all conditions for evolution
     */
    public boolean canEvolve() {
        boolean metConditions = true;
        for (boolean b : getEvolveConditions()) {
            metConditions = metConditions && b;
        }
        return species.canEvolve() && metConditions
                && (level >= getEvolveLevel()) && otherEvolveCondition;
    }

    public void addEvolveCondition(boolean condition) {
        otherEvolveCondition = condition;
    }

    /**
     * Get the minimum level at which the Pokemon can evolve
     *
     * @return the minimum level at which the Pokemon can evolve
     */
    public int getEvolveLevel() {
        return species.getEvolveLevel();
    }

    public boolean[] getEvolveConditions() {
        return species.getEvolveCondtions();
    }

    public Ability[] getAbilities() {
        return species.getAbilities();
    }

    public int[] getPercentLikelihoodAbilities() {
        return species.getPercentLikelihoodAbilities();
    }
    
    public Species getSpecies() {
        return species;
    }

    /*-------------------------------------- SETTERS -------------------------------------------*/
    /**
     * @param level the level to set
     */
    private void setLevel(int level) {
        this.level = level;
    }

    /**
     * @param exp the amount to add to exp
     */
    public void setExp(int exp) {
        this.exp += exp;
        if (exp <= expToNextLevel) {
            levelUp();
        }
    }

    /**
     * @param amount the amount to add to currentHP
     */
    public void setCurrentHP(int amount) {
        currentHP = modifyStat(this.currentHP, amount, 0, this.maxHP);
    }

    /**
     * @param maxHP the maxHP to set
     */
    public void setMaxHP(int maxHP) {
        this.maxHP = maxHP;
    }

    /**
     * @param friendliness the amount to add to friendliness
     */
    public void setFriendliness(int friendliness) {
        this.friendliness += (friendliness * friendlinessMultiplier);
        if (this.friendliness < 0) {
            this.friendliness = 0;
        }
    }

    /**
     * @param nickname the nickname to set
     */
    public void setNickname(String nickname) {
        this.nickname = nickname;
    }

    /**
     * @param item the item to set
     */
    public void setItem(Item item) {
        this.item = item;
    }

    /**
     * @param trainer the trainer to set
     */
    public void setTrainer(Trainer trainer) {
        this.trainer = trainer;
    }

    /**
     * @param moves the moves to set
     */
    public void setMoves(Move[] moves) {
        this.moves = moves;
    }

    /**
     * @param baseAttack the baseAttack to set
     */
    private void setBaseAttack(int baseAttack) {
        this.myBaseStats[ATTACK] = baseAttack;
    }

    /**
     * @param baseDefense the baseDefense to set
     */
    private void setBaseDefense(int baseDefense) {
        this.myBaseStats[DEFENSE] = baseDefense;
    }

    /**
     * @param baseSPAttack the baseSPAttack to set
     */
    private void setBaseSPAttack(int baseSPAttack) {
        this.myBaseStats[SP_ATTACK] = baseSPAttack;
    }

    /**
     * @param baseSPDefense the baseSPDefense to set
     */
    private void setBaseSPDefense(int baseSPDefense) {
        this.myBaseStats[SP_DEFENSE] = baseSPDefense;
    }

    /**
     * @param baseSpeed the baseSpeed to set
     */
    private void setBaseSpeed(int baseSpeed) {
        this.myBaseStats[SPEED] = baseSpeed;
    }

    /**
     * @param baseAccuracy the baseAccuracy to set
     */
    private void setBaseAccuracy(int baseAccuracy) {
        this.myBaseStats[ACCURACY] = baseAccuracy;
    }

    /**
     * @param baseEvasiveness the baseEvasiveness to set
     */
    private void setBaseEvasiveness(int baseEvasiveness) {
        this.myBaseStats[EVASIVENESS] = baseEvasiveness;
    }

    /**
     * @param attackMultiplier the attack multiplier to set
     */
    public void setAttackMultiplier(double attackMultiplier) {
        statMultipliers[ATTACK] = attackMultiplier;
    }

    /**
     * @param defenseMultiplier the defense to set
     */
    public void setDefenseMultiplier(double defenseMultiplier) {
        statMultipliers[DEFENSE] = defenseMultiplier;
    }

    /**
     * @param spAttackMultiplier the spAttack to set
     */
    public void setSpAttackMultiplier(double spAttackMultiplier) {
        statMultipliers[SP_ATTACK] = spAttackMultiplier;
    }

    /**
     * @param spDefenseMultiplier the spDefense to set
     */
    public void setSpDefenseMultiplier(double spDefenseMultiplier) {
        statMultipliers[SP_DEFENSE] = spDefenseMultiplier;
    }

    /**
     * @param speedMultiplier the speed to set
     */
    public void setSpeedMultiplier(double speedMultiplier) {
        statMultipliers[SPEED] = speedMultiplier;
    }

    /**
     * @param accuracyMultiplier the accuracy to set
     */
    public void setAccuracyMultiplier(double accuracyMultiplier) {
        statMultipliers[ACCURACY] = accuracyMultiplier;
    }

    /**
     * @param evasivenessMultiplier the evasiveness to set
     */
    public void setEvasivenessMultiplier(double evasivenessMultiplier) {
        statMultipliers[EVASIVENESS] = evasivenessMultiplier;
    }

    /**
     * @param attack the attack to set
     */
    public void setTempAttack(int attack) {
        currentStatModifiers[ATTACK] = attack;
    }

    /**
     * @param defense the defense to set
     */
    public void setTempDefense(int defense) {
        currentStatModifiers[DEFENSE] = defense;
    }

    /**
     * @param spAttack the spAttack to set
     */
    public void setTempSpAttack(int spAttack) {
        currentStatModifiers[SP_ATTACK] = spAttack;
    }

    /**
     * @param spDefense the spDefense to set
     */
    public void setTempSpDefense(int spDefense) {
        currentStatModifiers[SP_DEFENSE] = spDefense;
    }

    /**
     * @param speed the speed to set
     */
    public void setTempSpeed(int speed) {
        currentStatModifiers[SPEED] = speed;
    }

    /**
     * @param accuracy the accuracy to set
     */
    public void setTempAccuracy(int accuracy) {
        currentStatModifiers[ACCURACY] = accuracy;
    }

    /**
     * @param evasiveness the evasiveness to set
     */
    public void setTempEvasiveness(int evasiveness) {
        currentStatModifiers[EVASIVENESS] = evasiveness;
    }

    public void setIsConfused(boolean isConfused) {
        this.isConfused = isConfused;
    }

    private void setSpecies(int pokedexNo) {
        species = Pokedex.getPokemonSpeciesInfo(pokedexNo);
    }


    /*------------------------------------- BEHAVIOR -------------------------------------------*/
    public void resetHealth() {
        restoreFullHP();
        removeAllConditions();
    }

    public void removeAllConditions() {
        setIsConfused(false);
        removeCondition(Condition.POISON);
        removeCondition(Condition.BURN);
        removeCondition(Condition.PARALYSE);
        removeCondition(Condition.FREEZE);
        removeCondition(Condition.SLEEP);
    }

    public void removeCondition(Condition condition) {
        if (condition.equals(currentCondition)) {
            currentCondition = null;
        }
    }

    public void restoreFullHP() {
        currentHP = maxHP;
    }

    private int modifyStat(int base, int change, int min, int max) {
        base += change;
        if (base < min) {
            base = min;
        }
        if (base > max) {
            base = max;
        }
        return base;
    }

    /* (non-Javadoc)
    * @see pokemon.Breedable#canBreed()
    * todo - should this be handled by the Daycare center, and I only check
    *  myself
     */
    private boolean canBreed(Pokemon mate) {
        boolean b = false;
        for (EggGroup e : getEggGroup()) {
            if (e == EggGroup.UNDISCOVERED) {
                return false;
            }
        }
        for (EggGroup e : mate.getEggGroup())  {
            if (e == EggGroup.UNDISCOVERED) {
                return false;
            }
        }
        return mate.getEggGroup() == getEggGroup() && 
               mate.getGender() != getGender();
    }

    /* (non-Javadoc)
	 * @see pokemon.Breedable#breed()
     */
    public Egg breed(Pokemon mate) {
        //TODO inherited IVs with item dependency
        if (canBreed(mate)) {
            int[] inheritedIVs = new int[NUM_STATS + 1];
            for (int i = 0; i < inheritedIVs.length; i++) {
                inheritedIVs[i] = -1;
            }
            int numStatsInherited = 0;
            int numStatsToInherit = 3;
            if (item instanceof DestinyKnot || mate.getItem() instanceof DestinyKnot) {
                numStatsToInherit = 5;
            }
            while (numStatsInherited < numStatsToInherit) {
                int[] statsInherited = new int[numStatsToInherit];
                int statToInherit = generator.nextInt(NUM_STATS + 1);
                for (int x : statsInherited) {
                    if (statToInherit != x) {
                        statsInherited[numStatsInherited] = statToInherit;
                        numStatsInherited++;
                        //Inherit stat
                        if (generator.nextBoolean()) {
                            inheritedIVs[statToInherit] = this.ivs[statToInherit];
                        } else {
                            inheritedIVs[statToInherit] = mate.getIvs()[statToInherit];
                        }
                    }
                }
            }
            Nature eggNature = null;
            if (item instanceof Everstone) {
                eggNature = nature;
            } else if (mate.getItem() instanceof Everstone) {
                eggNature = mate.nature;
            }
            if (getGender() < mate.getGender()) {
//                return new Egg((Player) trainer, species.getBottomEvolution(),
//                        inheritedIVs, eggNature);
            } else {
//                return new Egg((Player) trainer, mate.getBottomEvolution(),
//                        inheritedIVs, eggNature);
            }
        }
        return null;
    }

    /**
     * Evolve to the next evolution in the chain
     */
    public void evolve() {
        if (canEvolve()) {
            int[] oldBaseStats = species.getSpeciesBaseStats();
            setSpecies(species.getNextEvolution());
            evolveStats(oldBaseStats);
        }
    }

    private void evolveStats(int[] oldBaseStats) {
        myBaseStats[ATTACK] = species.getSpeciesBaseStats()[ATTACK]
                + (getBaseAttack() - oldBaseStats[ATTACK]);
        myBaseStats[DEFENSE] = species.getSpeciesBaseStats()[DEFENSE]
                + (getBaseDefense() - oldBaseStats[DEFENSE]);
        myBaseStats[SP_ATTACK] = species.getSpeciesBaseStats()[SP_ATTACK]
                + (getBaseSpAttack() - oldBaseStats[SP_ATTACK]);
        myBaseStats[SP_DEFENSE] = species.getSpeciesBaseStats()[SP_DEFENSE]
                + (getBaseSpDefense() - oldBaseStats[SP_DEFENSE]);
        myBaseStats[SPEED] = species.getSpeciesBaseStats()[SPEED]
                + (getBaseSpeed() - oldBaseStats[SPEED]);

        myBaseStats[ACCURACY] = species.getSpeciesBaseStats()[ACCURACY]
                + (getBaseAccuracy() - oldBaseStats[ACCURACY]);
        myBaseStats[EVASIVENESS] = species.getSpeciesBaseStats()[EVASIVENESS]
                + (getBaseEvasiveness() - oldBaseStats[EVASIVENESS]);
    }

    public void levelUp() {
        setLevel(level + 1);
        evolve();
        updateStats();
        exp = 0;
        updateExpToNextLevel();
    }

    private void updateExpToNextLevel() {
        switch (levelGrowthRate) {
            case FAST:
                expToNextLevel = (int) (0.8 * Math.pow((double) level, 3.0));
            case MEDIUM_FAST:
                expToNextLevel = (int) (Math.pow((double) level, 3.0));
            case MEDIUM_SLOW:
                expToNextLevel = (int) ((1.2 * Math.pow((double) level, 3.0))
                        - (15 * Math.pow((double) level, 2.0))
                        + (100 * level) - 140);
            case SLOW:
                expToNextLevel = (int) (1.25 * Math.pow((double) level, 3.0));
        }
        if (expToNextLevel < 1) {
            expToNextLevel = 1;
        }
    }

    private void updateStats() {
        myBaseStats[ATTACK]
                = (int) (((ivs[ATTACK] + (2 * myBaseStats[ATTACK]) + (evs[ATTACK] / 4)) * (level / 100.) + 5) * natureValue[ATTACK]);
        myBaseStats[DEFENSE]
                = (int) (((ivs[DEFENSE] + (2 * myBaseStats[DEFENSE]) + (evs[DEFENSE] / 4)) * (level / 100.) + 5) * natureValue[DEFENSE]);
        myBaseStats[SP_ATTACK]
                = (int) (((ivs[SP_ATTACK] + (2 * myBaseStats[SP_ATTACK]) + (evs[SP_ATTACK] / 4)) * (level / 100.) + 5) * natureValue[SP_ATTACK]);
        myBaseStats[SP_DEFENSE]
                = (int) (((ivs[SP_DEFENSE] + (2 * myBaseStats[SP_DEFENSE]) + (evs[SP_DEFENSE] / 4)) * (level / 100.) + 5) * natureValue[SP_DEFENSE]);
        myBaseStats[SPEED]
                = (int) (((ivs[SPEED] + (2 * myBaseStats[SPEED]) + (evs[SPEED] / 4)) * (level / 100.) + 5) * natureValue[SPEED]);

        myBaseStats[ACCURACY] = (int) ((ivs[ACCURACY] + (2 * myBaseStats[ACCURACY]) + (evs[ACCURACY] / 4)) * (level / 100.) + 5);
        myBaseStats[EVASIVENESS] = (int) ((ivs[EVASIVENESS] + (2 * myBaseStats[EVASIVENESS]) + (evs[EVASIVENESS] / 4)) * (level / 100.) + 5);
    }

    public boolean isFainted() {
        return currentHP == 0;
    }

    /*----------------------------- OVERRIDES AND OUTPUT ------------------------------------*/
    public String pkmnSummary() {
        String s = toString() + "\n" + species.typesToString();
        return s + "\n" + printTrainer() + "\n"
                + printStats() + "\nPersonality: " + nature.toString()
                + "\n" + printMoves();
    }

    /* (non-Javadoc)
	 * @see java.lang.Object#toString()
     */
    @Override
    public String toString() {
        String s = "";
        if (nickname != null) {
            s += nickname + " [" + species.getName() + "] ";
        } else {
            s += species.getName() + ", ";
        }
        switch (gender) {
            case 0:
                s += "F ";
                break;
            case 1:
                s += "M ";
                break;
            case 2:
                s += "N ";
                break;
        }
        return s + " Lvl: " + level + "  EXP: " + exp + "/" + expToNextLevel + "  HP: " + currentHP + "/" + maxHP
                + "    " + conditionToString();
    }

    private String conditionToString() {
        String s = "";
        if (currentCondition != null) {
            switch (currentCondition) {
                case POISON:
                    s += "[Psn]";
                    break;
                case BURN:
                    s += "[Brn]";
                    break;
                case PARALYSE:
                    s += "[Prz]";
                    break;
                case FREEZE:
                    s += "[Frz]";
                    break;
                case SLEEP:
                    s += "[Slp]";
                    break;
            }
        }
        return s;
    }

    public String battleString() {
        String s = "";
        s += species.getName() + "   ";
        switch (gender) {
            case 0:
                s += "F ";
                break;
            case 1:
                s += "M ";
                break;
            case 2:
                s += "N ";
                break;
        }
        return s;
    }

    public String[] movesToStringArray() {
        String[] s = new String[moves.length];
        for (int i = 0; i < moves.length; i++) {
            s[i] = moves[i].toString();
        }
        return s;
    }

    private String printTrainer() {
        if (trainer != null) {
            return "Trainer: " + trainer.getName();
        }
        return "";
    }

    private String printStats() {
        String s = "";
        for (int i = 0; i < statNames.length; i++) {
            s += statNames[i] + ":" + addSpaces(statNames[i].length())
                    + (int) ((myBaseStats[i] + currentStatModifiers[i]) * statMultipliers[i])
                    + "\n";
        }
        return s;
    }

    private String printMoves() {
        int i = 0;
        String s = "Moves: ";
        for (Move m : moves) {
            if (m != null) {
                if (i % 2 == 0) {
                    s += "\n";
                } else {
                    s += "       ";
                }
                s += m.getName() + addSpaces(m.getName().length()) + "PP: "
                        + m.getCurrentPP() + "/" + m.getPP();
            }
            i++;
        }
        return s;
    }

    private String addSpaces(int length) {
        String s = "";
        for (int i = 0; i < 8 - length; i++) {
            s += " ";
        }
        return s;
    }

    public double getConditionModifier() {
        return CONDITION_EFFECT_VALUES[currentCondition.ordinal()];
    }

    public void setFriendlinessModifier(double d) {
        friendlinessMultiplier = d;
    }

    /**
     * @param effect
     * @param max
     */
    private void setEV(int stat, int effect, int max) {
        if (checkTotalEVs()) {
            if (evs[stat] < MAX_EV_PER_STAT) {
                if (evs[stat] < max) {
                    evs[stat] = evs[stat] + effect;
                    if (evs[stat] > max) {
                        evs[stat] = max;
                    }
                }
            }
            if (evs[stat] > MAX_EV_PER_STAT) {
                evs[stat] = MAX_EV_PER_STAT;
            }
        }
    }

    private boolean checkTotalEVs() {
        int numEVs = 0;
        for (int i : evs) {
            numEVs += i;
        }
        return numEVs < MAX_EV;
    }

    public int getAttackEV() {
        return evs[ATTACK];
    }

    public void setAttackEV(int effect, int max) {
        setEV(ATTACK, effect, max);
    }

    public void setAttackEV(int effect) {
        setAttackEV(effect, MAX_EV_PER_STAT);
    }

    public int getDefenseEV() {
        return evs[DEFENSE];
    }

    public void setDefenseEV(int effect, int max) {
        setEV(DEFENSE, effect, max);
    }

    public void setDefenseEV(int effect) {
        setDefenseEV(effect, MAX_EV_PER_STAT);
    }

    public int getSpAttackEV() {
        return evs[SP_ATTACK];
    }

    public void setSpAttackEV(int effect, int max) {
        setEV(SP_ATTACK, effect, max);
    }

    public void setSpAttackEV(int effect) {
        setSpAttackEV(effect, MAX_EV_PER_STAT);
    }

    public int getSpDefenseEV() {
        return evs[SP_DEFENSE];
    }

    public void setSpDefenseEV(int effect, int max) {
        setEV(SP_DEFENSE, effect, max);
    }

    public void setSpDefenseEV(int effect) {
        setSpDefenseEV(effect, MAX_EV_PER_STAT);
    }

    public int getSpeedEV() {
        return evs[SPEED];
    }

    public void setSpeedEV(int effect, int max) {
        setEV(SPEED, effect, max);
    }

    public void setSpeedEV(int effect) {
        setSpeedEV(effect, MAX_EV_PER_STAT);
    }

    public int getAccuracyEV() {
        return evs[ACCURACY];
    }

    public void setAccuracyEV(int effect, int max) {
        setEV(ACCURACY, effect, max);
    }

    public void setAccuracyEV(int effect) {
        setAccuracyEV(effect, MAX_EV_PER_STAT);
    }

    public int getEvasivenessEV() {
        return evs[EVASIVENESS];
    }

    public void setEvasivenessEV(int effect, int max) {
        setEV(EVASIVENESS, effect, max);
    }

    public void setEvasivenessEV(int effect) {
        setEvasivenessEV(effect, MAX_EV_PER_STAT);
    }

    public int getHPEV() {
        return evs[HP];
    }

    public void setHPEV(int effect, int max) {
        setEV(HP, effect, max);
    }

    public void setHPEV(int effect) {
        setHPEV(effect, MAX_EV_PER_STAT);
    }

    private int getEvRewardValue() {
        return species.getEvRewardValue();
    }

    private Stat getEvRewardType() {
        return species.getEvRewardType();
    }

    public boolean isConfused() {
        return isConfused;
    }

    public Condition getCurrentCondition() {
        return currentCondition;
    }

    public void setCurrentCondition(Condition currentCondition) {
        if (currentCondition == null) {
            //If we already have a condition we don't want it to change
            this.currentCondition = currentCondition;
        }
    }

    public Move pickMove(Pokemon target) {
        boolean[] validIndices = {true, true, true, true};
        int i = getBestMove(validIndices, target);
        while (moves[i] != null && moves[i].getCurrentPP() == 0) {
            validIndices[i] = false;
            i = getBestMove(validIndices, target);
        }
        return moves[i];
    }

    /**
     *
     * @param validIndices
     * @return the index of the best move to use; -1 if all moves have no PP
     */
    private int getBestMove(boolean[] validIndices, Pokemon target) {
        //TODO combo moves
        // if my health < 33%, a healing move is preferred
        if (currentHP < (maxHP / 3)) {
            for (int i = 0; i < moves.length; i++) {
                if (validIndices[i] && moves[i].getEffect().equals(MoveEffect.HEALING)) {
                    return i;
                }
            }
        }
        // if target does not have a condition, attack that inflicts condition preferred
        if (target.getCurrentCondition() == null) {
            for (int i = 0; i < moves.length; i++) {
                if (validIndices[i] && moves[i].getEffect().equals(MoveEffect.CONDITION)) {
                    return i;
                }
            }
        }
        // if target's type is weak against a move I have, that move is preferred
        for (int i = 0; i < moves.length; i++) {
            if (validIndices[i] && moves[i].getTypeResistance(target) > 1) {
                return i;
            }
        }
        // if my health is very high, and I can do stat changes, change stats
        if (currentHP > (maxHP * .75)) {
            for (int i = 0; i < moves.length; i++) {
                if (validIndices[i] && moves[i].getEffect().equals(MoveEffect.STAT)) {
                    return i;
                }
            }
        }
        // if my health is low (< 25%) and my target's health is above 25%, try to disable them or use Substitute or block/dodge
        if (currentHP < (maxHP / 4) && (target.getCurrentHP() >= (target.getMaxHP() / 4))) {
            //TODO disabling moves (paralyse, freeze, sleep)
            //TODO substitute
            for (int i = 0; i < moves.length; i++) {
                if (validIndices[i] && moves[i].getEffect().equals(MoveEffect.DODGE_BLOCK)) {
                    return i;
                }
            }
            // if i can't do any of those, moves that raise my defense or lower their attack are preferred
            // TODO lower attack, check for raise/lower of stats
            for (int i = 0; i < moves.length; i++) {
                if (validIndices[i] && moves[i].getEffect().equals(MoveEffect.STAT)) {
                    return i;
                }
            }
        }
        // find the move which has the greatest power : accuracy ratio
        int index = -1;
        double maxRatio = 0;
        for (int i = 0; i < moves.length; i++) {
            if (validIndices[i]) {
                double ratio = moves[i].getPower() / moves[i].getAccuracy();
                if (ratio > maxRatio) {
                    maxRatio = ratio;
                    index = i;
                }
            }
        }
        return index;
    }

    private Move getMoveFromString(String moveName) {
        for (Move m : species.getMoveSet()) {
            if (m.getName().equalsIgnoreCase(moveName)) {
                return m;
            }
        }
        throw new BadSaveDataException("Bad Move");
    }
}
